<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on codegangsta.io</title>
    <link>http://codegangsta.io/categories/golang/</link>
    <description>Recent content in Golang on codegangsta.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 May 2014 10:51:49 -0800</lastBuildDate>
    <atom:link href="http://codegangsta.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My Thoughts on Martini</title>
      <link>http://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/</link>
      <pubDate>Mon, 19 May 2014 10:51:49 -0800</pubDate>
      
      <guid>http://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s never easy to take honest criticism, especially when the target of the criticism is considered your &amp;lsquo;baby&amp;rsquo;. Earlier this week, &lt;a href=&#34;http://stephensearles.com/?p=254&#34;&gt;Stephen Searles posted an entirely honest review&lt;/a&gt; of Martini and how, despite the popularity and hype, there are numerous reasons why Martini should not be used.&lt;/p&gt;

&lt;p&gt;I have been asked by many people what my thoughts are regarding the reasons not to use Martini. I figure that it would be best to compile these thoughts into a blog post so I can shed some light on my opinions and how they may have changed over time. So here we go, my reflections on Martini&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;martini-s-popularity-was-a-huge-surprise:be092bb3a2ecafb4d15d135163b61d62&#34;&gt;Martini&amp;rsquo;s Popularity was a HUGE surprise&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Arguably, many people at the time were young Go developers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This may be an obvious one. I was not expecting the positive attention that Martini received when I made the initial announcement. I was extremely surprised to see my little experiment of doing dependency injection in Go become popular so quickly. It was so well received that my inbox was flooded with emails for weeks, Martini blog posts were all over the internet, and hundreds of contributions were added to both the Martini and martini-contrib GitHub repos.&lt;/p&gt;

&lt;p&gt;Not only was this unexpected, I was still very young as a Go developer. Arguably, many people at the time were young Go developers. I doubted some of the decisions I made with Martini, but soon those doubts were drowned out by the positive reenforcement relayed by the Go community. In my mind Martini was a great fit for the Go community because people liked it! It&amp;rsquo;s popular, so it must be the best choice right? It&amp;rsquo;s completely idiomatic right? Right?!&lt;/p&gt;

&lt;h2 id=&#34;martini-is-not-idiomatic:be092bb3a2ecafb4d15d135163b61d62&#34;&gt;Martini is not Idiomatic&lt;/h2&gt;

&lt;p&gt;As I grew from a baby gopher to a well respected Go developer in the community, this was the toughest pill for me to swallow. &lt;em&gt;Martini, and it&amp;rsquo;s design, is simply not idiomatic Go.&lt;/em&gt; This is not to say that Martini is not well designed, I feel like it is one of my better demonstrations of API design that I&amp;rsquo;ve had in my career. There have been many excellent patterns for web development that have been executed in the Martini codebase and many very high quality web packages found in martini-contrib. The contributions can be attributed to the great community surrounding Martini and the design of the framework itself.&lt;/p&gt;

&lt;p&gt;Despite all of these facts, Martini is still not idiomatic Go. The mantras surrounding to Go community are simplicity, familiarity with the stdlib, and explicit interactions with the type system. Martini does not line up with the way the stdlib was designed, and it therefore can never be considered idiomatic. This doesn&amp;rsquo;t make Martini wrong, it is just not going in the direction that the Go community as a whole is going.&lt;/p&gt;

&lt;h2 id=&#34;martini-reflection-is-flawed:be092bb3a2ecafb4d15d135163b61d62&#34;&gt;Martini reflection is flawed&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The real tradeoff with reflection is one of complexity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the crowning features of Martini is it&amp;rsquo;s reflective dependency injection. From a modularity perspective it sounds awesome! Martini handlers only get the dependencies they need, services can be injected, mocked, swapped out, and fulfilled by this method of dependency provisioning. The problem is that the reflection comes at a cost, both in performance and complexity.&lt;/p&gt;

&lt;p&gt;In most situations, the performance overhead is negligible compared to the other components required in building a web application/api. The real tradeoff with reflection is one of complexity. Rather than have a strict interface for implementing and extending a web application, Martini allows you to &lt;em&gt;inject all the things&lt;/em&gt; and that leads to a level of indirection that, while modular, requires a certain amount of cognitive overhead to fully understand what is actually going on.&lt;/p&gt;

&lt;h2 id=&#34;so-now-what:be092bb3a2ecafb4d15d135163b61d62&#34;&gt;So&amp;hellip; Now What?&lt;/h2&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://makeameme.org/media/created/who-am-i-bmup6m.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;If you are using Martini, please continue using it. If you are interested in using Martini, it is still a fantastic framework and arguably the most productive set of tools for building web applications in Go. It is well designed and has a great community around it. Martini is not going away, and I&amp;rsquo;m not going to stop supporting Martini.&lt;/p&gt;

&lt;p&gt;All that said, I still want to accomplish the goal I was originally set out to accomplish when I first created Martini; promote the creation of awesome reusable web components for Go. I recently have been thinking about how I could take the good parts of Martini and combine them into a package that is simple, beautiful, non-intrusive, and most of all &lt;em&gt;idiomatic&lt;/em&gt; Go.&lt;/p&gt;

&lt;h2 id=&#34;introducing-negroni:be092bb3a2ecafb4d15d135163b61d62&#34;&gt;Introducing Negroni&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://negroni.codegangsta.io&#34;&gt;Negroni&lt;/a&gt; is a idiomatic approach to middleware in &lt;code&gt;net/http&lt;/code&gt;. I wrote it as an alternative to Martini and it attempts to accomplish similar goals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Non-intrusive design&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Compatibility with net/http&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Super easy to use&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Promote good practices&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://negroni.codegangsta.io&#34;&gt;Negroni&lt;/a&gt; does one thing well, net/http middleware. It comes with the same default middleware that Martini comes with; Logging, Panic Recovery, and Static file serving. The API is simple and intuitive. Most of all, this middleware stack does not use reflection or dependency injection, and building middleware for Negroni requires no dependencies outside of net/http. Here is a quick example of how to use Negroni to compose a feature full middleware stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;github.com/codegangsta/negroni&amp;quot;
  &amp;quot;net/http&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {
  mux := http.NewServeMux()
  mux.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintf(w, &amp;quot;Welcome to the home page!&amp;quot;)
  })

  // Use the default middleware.
  n := negroni.Classic()
  // ... Add any other middlware here
  
  // add the router as the last handler in the stack
  n.UseHandler(mux)
  n.Run(&amp;quot;:3000&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://negroni.codegangsta.io&#34;&gt;Negroni&lt;/a&gt; is not considered a framework as it does not have a built in router. There are many great http routers already available to to the Go community already. The goal of Negroni is to be focused on the problem that Martini was originally set out to resolve.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m interested in hearing your thoughts on the package, if you are interested in hearing more from me on the subject, feel free to comment below. Also, &lt;a href=&#34;http://negroni.codegangsta.io&#34;&gt;be sure to give Negroni a star on GitHub&lt;/a&gt; so we can create a vibrant community around reusable net/http handlers for Go!&lt;/p&gt;

&lt;p&gt;Keep on building awesome things.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Distributing Command line Applications: Why I switched from Ruby to Go</title>
      <link>http://codegangsta.io/blog/2013/07/21/creating-cli-applications-in-go/</link>
      <pubDate>Sun, 21 Jul 2013 16:28:53 -0800</pubDate>
      
      <guid>http://codegangsta.io/blog/2013/07/21/creating-cli-applications-in-go/</guid>
      <description>

&lt;p&gt;For as long as I have been using it, my go-to language for creating CLI applications was Ruby. After all, Ruby is a robust, mature language with many things to make us developers want to gyrate with joy (okay maybe that is just me).&lt;/p&gt;

&lt;p&gt;To this day I still hold the opinion that Ruby provides the most elegant amount of expression when it comes to my everyday programming activities. Whether it is the language or the community that fosters clean code, I feel like an artisan every time I sit down to write an application or library in Ruby.&lt;/p&gt;

&lt;p&gt;There is something so elegant and beautiful about creating a command line application with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;desc &amp;quot;A todo application&amp;quot;
app :todo do
  desc &amp;quot;add a todo&amp;quot;
  command :add do
    puts &amp;quot;Your todo has been added&amp;quot;
  end
  desc &amp;quot;remove a todo&amp;quot;
  command :remove do
    puts &amp;quot;your todo has been removed&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;distributing-ruby:9f17f9546a36a228d9fba12b21130b57&#34;&gt;Distributing Ruby&lt;/h2&gt;

&lt;p&gt;While the code is beautiful, distributing Ruby programs is not. Now - I don&amp;rsquo;t want to make you believe that program distribution should be an easy thing, because it definitely is not. There are so many things that can possibly go wrong with an application when you expect it to leave your programming and test environments to run perfectly on your end users machines. Let me say it again; &lt;em&gt;Distributing programs is &lt;strong&gt;hard work!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m sure you are thinking, &amp;ldquo;Why not distribute your app via Rubygems?&amp;rdquo;. After attempting the distribution of a command line application via Rubygems I came to the following conclusion: &lt;strong&gt;Any application not intended exclusively for Rubyists should not be distributed via Rubygems.&lt;/strong&gt; Luckily &lt;a href=&#34;http://mitchellh.com/abandoning-rubygems&#34;&gt;I am not the only one&lt;/a&gt; who holds this position on distribution, so that leads those of us that wish to use Ruby on a long road to properly distribute a command line application.&lt;/p&gt;

&lt;h2 id=&#34;custom-ruby-and-vendoring:9f17f9546a36a228d9fba12b21130b57&#34;&gt;Custom Ruby and Vendoring&lt;/h2&gt;

&lt;p&gt;The next natural option with Ruby would be to distribute your entire application independent of RubyGems. So you &lt;em&gt;really&lt;/em&gt; only have one good option here, and that is to &lt;a href=&#34;http://yehudakatz.com/2012/06/05/tokaido-status-update-implementation-details/&#34;&gt;compile a custom version of Ruby&lt;/a&gt; to distribute with each OS installer (Yes, you must have an installer) of your application. Just so you don&amp;rsquo;t mess with a users current installation you must compile under a custom prefix; something along the lines of &lt;code&gt;/usr/local/&amp;lt;yourapp&amp;gt;/ruby&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once this is done it is important to make sure you vendor and distribute all of your gems that you use for your application. This can get nasty when it comes to native gems that rely on local dynamic libraries. Anyway, I hope you get the picture that &lt;em&gt;distributing a ruby app to end users can be a hassle.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;building-it-in-go:9f17f9546a36a228d9fba12b21130b57&#34;&gt;Building it in Go&lt;/h2&gt;

&lt;p&gt;If you are adventurous you have probably played with, or heard of the &lt;a href=&#34;http://golang.org/&#34;&gt;Go programming language&lt;/a&gt;. In fact I have started to blog about it for the past couple of weeks. My recent love affair with Go has led me to believe that distributing applications to end users in Go is a much simpler process than languages like Ruby.&lt;/p&gt;

&lt;p&gt;Since Go is a compiled language, binaries of your app can be precompiled for each platform that you wish to distribute for. While not as portable as C, (and who can be, C compilers are everywhere!) Go provides a lightweight set of tools that can compile on many platforms for those who wish their end users to compile from source.&lt;/p&gt;

&lt;h2 id=&#34;introducing-cli-go:9f17f9546a36a228d9fba12b21130b57&#34;&gt;Introducing cli.go&lt;/h2&gt;

&lt;p&gt;While I loved the simplicity in distributing an application in Go, I missed that expressiveness that I got from Ruby, so (shameless plug) I rolled my own CLI library called &lt;a href=&#34;https://github.com/codegangsta/cli&#34;&gt;cli.go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/codegangsta/cli&#34;&gt;cli.go&lt;/a&gt; provides that expressive, &amp;ldquo;Document as you code&amp;rdquo; model for building command line applications in Go. It is easily distributable and super fast! Building real command line apps is as easy as this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;os&amp;quot;
import &amp;quot;github.com/codegangsta/cli&amp;quot;

func main() {
  app := cli.NewApp()
  app.Name = &amp;quot;boom&amp;quot;
  app.Usage = &amp;quot;make an explosive entrance&amp;quot;
  app.Action = func(c *cli.Context) {
    println(&amp;quot;boom! I say!&amp;quot;)
  }

  app.Run(os.Args)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go check out the &lt;a href=&#34;https://github.com/codegangsta/cli&#34;&gt;cli.go&lt;/a&gt; repo. &lt;strong&gt;Star&lt;/strong&gt; it, &lt;strong&gt;fork&lt;/strong&gt; it, &lt;strong&gt;Contribute&lt;/strong&gt; to it. Let&amp;rsquo;s make Go the go-to language for command line tools!&lt;/p&gt;

&lt;p&gt;Keep writing beautiful code.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>